// Compile CSMain as a compute kernel.
#pragma kernel CSMain

#define WAVE_COUNT 8
#define PI 3.14159265359

uint inPointCount;
uint inWobblePointCount;

float inFlyProgress;
float inRippleMagnitude;

RWStructuredBuffer<float3> bezierPoints;
RWStructuredBuffer<float3> bezierIntPoints;

RWStructuredBuffer<float3> outPoints;

// float3 lerp helper function.
float3 Lerp(float3 a, float3 b, float t) 
{
	return a + ((b - a) * t);
}

// Evaluate provided bezier curve.
float3 EvaluateCurve(RWStructuredBuffer<float3> points, uint threadIdx, uint startIndex, uint pointCount, float progress) 
{
	// Clamp progress between 0 and 1.
	if (progress > 1.0f)
		progress = 1.0f;
	else if (progress < 0.0f)
		progress = 0.0f;

	uint intPointIndex = threadIdx * pointCount;

	// Interpolate all line segments...
	bezierIntPoints[intPointIndex] = Lerp(points[startIndex], points[startIndex + 1], progress);
	
	for(uint i = 1; i < pointCount; ++i)
	{
		uint trueIndex = intPointIndex + i;

		bezierIntPoints[trueIndex] = Lerp(bezierIntPoints[trueIndex - 1], Lerp(points[(startIndex + i) - 1], points[startIndex + i], progress), progress);
	}

	return bezierIntPoints[intPointIndex + (pointCount - 1)];
}

[numthreads(256,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	// Get dimensions of output array.
	uint outPointCount = 0;
	uint outPointStride = 0;
	outPoints.GetDimensions(outPointCount, outPointStride);

	outPointCount /= 2;

	// Get point's point along the line.
	float progress = ((float)id.x / outPointCount) * inFlyProgress;

	// Rope wave
	float waveInput = pow((1.0f - progress), 2) * WAVE_COUNT * PI;
	float fCurveMag = sin(waveInput);
	float fCurveMagY = -cos(waveInput);

	// Directions
	float3 ropeDir = normalize(bezierPoints[0] - bezierPoints[inPointCount - 1]);
	float3 rippleDir = cross(ropeDir, float3(0.0f, 1.0f, 0.0f));

	float3 rippleVec = float3(0.0f, 0.0f, 0.0f);

	if (id.x > 0 && id.x < outPointCount - 1) 
	{
		outPoints[outPointCount + id.x] = Lerp(outPoints[outPointCount + id.x], EvaluateCurve(bezierPoints, id.x, inPointCount, inWobblePointCount, progress), 0.1f);

		float power = pow((1.0f - progress), 5);

		rippleVec = (rippleDir * power  * fCurveMag) + (float3(0.0f, 1.0f, 0.0f) * power * fCurveMagY); // Ripple vector

		// Multipliers
		rippleVec *= max((inRippleMagnitude - (pow(inFlyProgress, 5) * inRippleMagnitude)), 0.8f);
		rippleVec *= inRippleMagnitude;
	}

	// Evaluate curve for output point.
	outPoints[id.x] = EvaluateCurve(bezierPoints, id.x, 0, inPointCount, progress) + outPoints[outPointCount + id.x] + rippleVec;
}
