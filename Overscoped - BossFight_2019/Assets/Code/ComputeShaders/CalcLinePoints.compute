// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
//RWTexture2D<float4> Result;

uint pointCount;

RWStructuredBuffer<float3> bezierPoints;
RWStructuredBuffer<float3> bezierIntPoints;

RWStructuredBuffer<float3> outPoints;

// float3 lerp helper function.
float3 Lerp(float3 a, float3 b, float t) 
{
	return a + ((b - a) * t);
}

// Evaluate provided bezier curve.
float3 EvaluateCurve(RWStructuredBuffer<float3> points, uint threadIdx, uint pointCount, float progress) 
{
	// Clamp progress between 0 and 1.
	if (progress > 1.0f)
		progress = 1.0f;
	else if (progress < 0.0f)
		progress = 0.0f;
	
	float3 intPoints[4];
	
	uint intPointIndex = threadIdx * pointCount;

	// Interpolate all line segments...
	bezierIntPoints[intPointIndex] = Lerp(points[0], points[1], progress);
	
	for(uint i = 1; i < pointCount; ++i)
	{
		uint trueIndex = intPointIndex + i;

		bezierIntPoints[trueIndex] = Lerp(bezierIntPoints[trueIndex - 1], Lerp(points[i - 1], points[i], progress), progress);
	}

	return bezierIntPoints[intPointIndex + (pointCount - 1)];
}

[numthreads(256,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	// Get dimensions of output array.
	uint outPointCount = 0;
	uint outPointStride = 0;
	outPoints.GetDimensions(outPointCount, outPointStride);

	// Get point's point along the line.
	float progress = (float)id.x / outPointCount;

	// Evaluate curve for output point.
	outPoints[id.x] = EvaluateCurve(bezierPoints, id.x, pointCount, progress);
}
